# 프로그래머스 피드백
* 과제 찾기 프롬프트
* ```Markdown
  프로그래머스에 '구현' 문제 'Lv1' 2개, 'Lv2' 1개 추천해봐. 인터넷에서 최근에 언급 많고 추천 많은 문제로
  프로그래머스에 'DFS' 문제 'Lv2' 1개 추천해봐. 인터넷에서 최근에 언급 많고 추천 많은 문제로
  ```

## `[구현]`

### [유용한 라이브러리]
* 대소문자 변환: lower() upper(), (Lv1_1)
* 앞뒤에 모든 점 제거: strip('.'), (Lv1_1)
* 길이로 리스트 소팅하기: sort(key=len), (Lv2_1)
* 세트 자료형, (Lv2_1)
    * 중복 제거: seen = set()
    * 원소 추가: seen.add(item)
* 숫자인지 확인하기: isdigit(), (Lv2_2)
* 카운터 라이브러리, (Lv2_3)
    * 등장 횟수 세는 라이브러리
    * from collections import Counter
    * a = ['a', 'b', 'b', 'b', 'c', 'c', 'c', 'c', 'd']
    * c = Counter(a)
    * print(c) # Counter({'a': 1, 'b': 3, 'c': 4, 'd': 1})
    * c['a'] -= 1
    * print(c) # Counter({'a': 0, 'b': 3, 'c': 4, 'd': 1})
    * if c['a'] == 0: del c['a']
    * print(c) # Counter({'b': 3, 'c': 4, 'd': 1})
* 띄어 쓰기 기준 자르기: split(), (Lv1_4)
* 2진수로 바꾸는 라이브러리: bin(n)[2:], (Lv1_5)
* n자리로 맞추기: zfill(n), (Lv1_5)
* 리스트에서 인덱스 호출: list.index(value), (Lv1_6)
<br><br>

### [오타 주의]
* endwith() 가 아니라 endswith(), (Lv1_1)
<br><br>



## `[DFS & BFS]`

### [문제 해결 프로세스]
* 문제 도식화, 텍스트로 된 그림 그리기
* 도식 -> 재귀 시 누가 누구에게 무엇을 주는지 잘 보기
* 필수 요소
    * 초기화, 종료 조건, 재귀
    * 목적이 무엇이고 리턴이 무엇인가
* 코딩하는 순서가 중요함
    * 1: 전체 프로세스 (DFS & BFS 제외)
    * 2: DFS & BFS 내부 프로세스
    * 3: DFS & BFS 종료 조건, 리턴 어디서 뭘 할지
<br><br>

### [유용한 라이브러리]
* 재귀 깊이 해제: sys.setrecursionlimit(10000)
* 바로 바깥 변수 접근: nonlocal var_name
<br><br>

### [유형 분석]
* DFS: 연결 요소 카운팅 형태
    * (ex. 네트워크, 음료수 얼려 먹기)
    * 핵심1: 목적은 모든 노드 방문 처리 (=리턴 없음) (종료 조건 = all visited)
    * 핵심2: 다음 깊이 탐색 대상 노드에서 재귀 호출
    * 핵심3: 언제 덩어리를 카운트 할지 `생각하기`
* DFS: 경우의 수 형태
    * (ex. 타겟 넘버)
    * 핵심1: 목적은 경우의 수 세기 (=리턴)
    * 핵심2: 시작점을 기준으로 분기되는 모든 경우의 수 재귀 호출
* DFS: 연결 요소 연산 형태
    * (ex. 무인도 여행)
    * 핵심1: 카운팅에서 변수를 추가 설정 후 상세 연산 (필요 시 리스트 담기)
* DFS: 순열 형태
    * (ex. 소수 찾기)
    * 핵심1: 순열으로 풀리는 경우 순열 사용
* BFS: 최단 경로 형태
    * (ex. 미로 탈출, 게임 맵 최단거리)
    * 핵심1: 전체 프로세스 (BFS 제외)는 그저 BFS를 호출하는 것이 끝
<br><br>



## `[그리디]`
* 그리디 = 수학적으로 최적인 것을 선택 (cf. 구현 = 무념무상 단계 따라 코딩)
<br><br>

### [유용한 라이브러리]
* 리스트에서 요소 수 세기: lottos.count(0)
<br><br>



## `[DP]`

### [유용한 라이브러리]
* 
<br><br>

### [유형 분석]
* 바텀업 최댓값 최솟값 구하기
    * (ex. 개미 전사, 효율적인 화폐 구성)
    * 핵심1: 0번부터 전부 구한다, max() or min() 사용
    * 핵심2: 적절한 점화식 완성하기
    * 핵심3: 업데이트 할 값이 뭔지 잘 생각하기 (+1, +k 등)
* 매번 최선의 경우의 수 고르기
    * (ex. 1로 만들기, 금광)
    * 핵심1: if문의 떡칠이 될 가능성이 있음
    * 핵심2: 어쩌면 반대쪽에서 오는게 더 좋을 수 있음
    * 핵심3: 업데이트 할 값이 뭔지 잘 생각하기 (+1, +k 등)
* LIS 알고리즘
    * (ex. 병사 배치하기)
    * 핵심1: 해당 위치가 마지막일 때, 그 수 보다 작은 값을 찾는 조건문
    * 핵심2: 값이 가장 큰 원소로 메모이제이션 업데이트
<br><br>
